



<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Car Chase</title>
    <style>
    html, body {
        margin: 0;
        height: 100%;
    }
    #c {
        width: 100%;
        height: 100%;
        display: block;
    }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
  </body>
<script type="module">
import * as THREE from "/three.js-master/build/three.module.js";
import {OrbitControls} from '/three.js-master/examples/jsm/controls/OrbitControls.js';
import {OBJLoader} from '/three.js-master/examples/jsm/loaders/OBJLoader.js';
import { Water } from '/three.js-master/examples/jsm/objects/Water2.js';
const scene = new THREE.Scene();

/* 
DISCLAIMER: 
  THOUGH IT IS ALLOWED IN THE ASSIGNMENT, MUCH OF THIS CODE IS HEAVY INSPIRATION FROM DIFFERENT EXAMPLES ON
  https://threejs.org/manual/#en/fundamentals MANUAL. THE SCENE IS OF MY ORGINAL DESIGN,
  HOWEVER SOME FUNCTIONS AND FEATURES ARE STRIGHT FROM THE MANUAL, SUCH AS THE WATER/VIEW CONTROLS/ETC..
*/
function main() {
  // ------------------- Camera Controls -----------------------
  const canvas = document.querySelector('#c');
  const renderer = new THREE.WebGLRenderer({canvas});
  const fov = 90;
  const aspect = 2;  // the canvas default
  const near = 0.1;
  const far = 5000;
  const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
  camera.position.set(-475, 305, -57);
  camera.lookAt(500,103,200);

  const controls = new OrbitControls(camera, canvas);
  controls.target.set(0, 5, 0);
  controls.update();

   // ------------------- Scene Creation -----------------------
  
  scene.background = new THREE.Color('gray');
  scene.fog = new THREE.Fog('gray', near, 1000);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap

   // ------------------- Plane Controls -----------------------
  {
    const planeSize = 1;

    const loader = new THREE.TextureLoader();
    const texture = loader.load('resources/images/grass.png');
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.magFilter = THREE.NearestFilter;
    const repeats = planeSize / 2;
    texture.repeat.set(repeats, repeats);
    const planeGeo = new THREE.PlaneGeometry(planeSize, planeSize);
    const planeMat = new THREE.MeshPhongMaterial({
      map: texture,
      side: THREE.DoubleSide,
    });
    const mesh = new THREE.Mesh(planeGeo, planeMat);
    mesh.rotation.x = Math.PI * -.5;
    scene.add(mesh);
  }

   // ------------------- SkyBox Controls -----------------------
  {
    const loader = new THREE.TextureLoader();
    const texture = loader.load(
    'resources/images/sky.png',
    () => {
      const rt = new THREE.WebGLCubeRenderTarget(texture.image.height);
      rt.fromEquirectangularTexture(renderer, texture);
      scene.background = rt.texture;
    });
  }
   // ------------------- Light Controls -----------------------
  {
    const skyColor = 0xB1E1FF;  // light blue
    const groundColor = 0xB97A20;  // brownish orange
    const intensity = 0.2;
    const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
    scene.add(light);
  }

  {
    const color = 0xFFFFFF;
    const intensity = 0.3;
    const light = new THREE.DirectionalLight(color, intensity);
    light.position.set(0, 100, 100);
    light.target.position.set(0, 0, 0);
    scene.add(light);
    scene.add(light.target);
  }

  //-Front Headlights-
  {
    const spotLight = new THREE.SpotLight( 0xffffff );
    const helper = new THREE.CameraHelper(spotLight.shadow.camera);
    spotLight.target.position.set(170,120,80);
    spotLight.position.set( 160, 115, 35);

    spotLight.castShadow = true;
    spotLight.intensity = 0.8;
    spotLight.angle = Math.PI/6;
    
    

    
    
    //scene.add(helper)
    scene.add( spotLight );
    scene.add(spotLight.target);
    
  }

  {
    const spotLight2 = new THREE.SpotLight( 0xffffff );
    spotLight2.target.position.set(190,120,75);
    spotLight2.position.set( 170, 115, 30);

    spotLight2.castShadow = true;
    spotLight2.intensity = 0.8;
    spotLight2.angle = Math.PI/6;
    

    spotLight2.shadow.mapSize.width = 1024;
    spotLight2.shadow.mapSize.height = 1024;

    spotLight2.shadow.camera.near = 1;
    spotLight2.shadow.camera.far = 4000;
    spotLight2.shadow.camera.fov = 30;
    const helper2 = new THREE.CameraHelper(spotLight2.shadow.camera);
    //scene.add(helper2)

    scene.add( spotLight2 );
    scene.add(spotLight2.target);
  }

  //-Back Lights-

  {
    const spotLight3 = new THREE.SpotLight( 0xff0000 );
    spotLight3.target.position.set(145,105,-20);
    spotLight3.position.set( 165, 115, 25);

    spotLight3.castShadow = true;
    spotLight3.intensity = 0.3;
    spotLight3.angle = Math.PI/6;
    

    spotLight3.shadow.mapSize.width = 1024;
    spotLight3.shadow.mapSize.height = 1024;

    spotLight3.shadow.camera.near = 500;
    spotLight3.shadow.camera.far = 4000;
    spotLight3.shadow.camera.fov = 30;

    scene.add( spotLight3 );
    scene.add(spotLight3.target);
  }

  {
    const spotLight4 = new THREE.SpotLight( 0xff0000 );
    spotLight4.target.position.set(135,105,-15);
    spotLight4.position.set( 155, 115, 40);

    spotLight4.castShadow = true;
    spotLight4.intensity = 0.3;
    spotLight4.angle = Math.PI/8;
    

    spotLight4.shadow.mapSize.width = 1024;
    spotLight4.shadow.mapSize.height = 1024;

    spotLight4.shadow.camera.near = 500;
    spotLight4.shadow.camera.far = 4000;
    spotLight4.shadow.camera.fov = 30;

    scene.add( spotLight4 );
    scene.add(spotLight4.target);
  }


  // HELICOPTER ! 
  {
    const helicopterLight = new THREE.SpotLight( 0xADD8E6 );
    const helper = new THREE.CameraHelper(helicopterLight.shadow.camera);
    helicopterLight.target.position.set(161,103,30);
    helicopterLight.position.set( 215,200,0);

    helicopterLight.castShadow = true;
    helicopterLight.intensity = 0.4;
    helicopterLight.angle = Math.PI/17;
    
    

    
    
    //scene.add(helper)
    scene.add( helicopterLight );
    scene.add(helicopterLight.target);
    
  }
  {
    const helilight = new THREE.PointLight( 0xff00ff, 1, 100 );
    helilight.position.set( 170,120,40 );
    scene.add( helilight );
    
  }
  
// -------------------- WATER ------------------

  {
    const params = {
				color: '#ffffff',
				scale: 5,
				flowX: 1,
				flowY: 1
			};


    const waterGeometry = new THREE.PlaneGeometry( 2500, 2500 );

    let water = new Water( waterGeometry, {
    color: params.color,
    scale: params.scale,
    flowDirection: new THREE.Vector2( params.flowX, params.flowY ),
    textureWidth: 1024,
    textureHeight: 1024
  } );
    water.position.y = 40;
    water.rotation.x = Math.PI * - 0.5;
    scene.add( water );


  }

  // ------------------- Sparks -------------------
    {
      var geometryParticle = new THREE.CylinderGeometry( 0.1, 0.1,0.1 );
    var materialParticle = new THREE.MeshBasicMaterial( { color: 0xFFA500, transparent: true } );
    for(var i = 0; i< 1000; i++){
      var offsetx = Math.random() * ((20 - (-20)) + (-20));
      var offsetz = Math.random() * ((40 - 0) + (0));
      var offsety = Math.random() * ((5 - (-5)) + (-5));
      var particle = new THREE.Mesh( geometryParticle, materialParticle );
      particle.position.set(140+ offsetx,105+ offsety,15 - offsetz);
      scene.add(particle);
    }
    
    }

    {
      var geometryParticle = new THREE.SphereGeometry( 0.1, 0.1,0.1 );
    var materialParticle = new THREE.MeshBasicMaterial( { color: 0xff8c00, transparent: true } );
    for(var i = 0; i< 1000; i++){
      var offsetx = Math.random() * ((20 - (-20)) + (-20));
      var offsetz = Math.random() * ((40 - 0) + (0));
      var offsety = Math.random() * ((5 - (-5)) + (-5));
      var particle = new THREE.Mesh( geometryParticle, materialParticle );
      particle.position.set(140+ offsetx,105+ offsety,15 - offsetz);
      scene.add(particle);
    }
    
    }

   // ------------------- Objects Controls -----------------------
  {
    var textureLoader = new THREE.TextureLoader();
    var map = textureLoader.load('/resources/images/black.jpg');
    var material = new THREE.MeshPhongMaterial({map: map});
    var loader = new OBJLoader();
    loader.load( '/resources/car.obj', function ( object ) {
  // For any meshes in the model, add our material.
    object.traverse( function ( node ) {
      if ( node.isMesh ) node.material = material;
    } );
    // Add the model to the scene.
    object.position.y = 103;
    object.position.x = 161;
    object.position.z = 30;
    object.rotation.y = Math.PI / 7;
    object.castShadow = true;
    object.receiveShadow = false;
    scene.add( object );
} );
  }


  {
    var textureLoader2 = new THREE.TextureLoader();
    var map2 = textureLoader2.load('/resources/images/cany.jpg');
    var material2 = new THREE.MeshPhongMaterial({map: map2});
    var loader2 = new OBJLoader();
    loader2.load( '/resources/map.obj', function (canyon ) {
  // For any meshes in the model, add our material.
   canyon.traverse( function ( node ) {
      if ( node.isMesh ) node.material = material2;
    } );
   canyon.rotation.x = -Math.PI / 2;
    // Add the model to the scene.
    canyon.castShadow = false;
    canyon.receiveShadow = true;
    canyon.scale.set = (2,2,2)
    scene.add(canyon );
} );
  }


  {
    var textureLoader3 = new THREE.TextureLoader();
    var map3 = textureLoader3.load('/resources/images/cany2.png');
    var material3 = new THREE.MeshPhongMaterial({map: map3});
    var loader3 = new OBJLoader();
    loader3.load( '/resources/Old stone bridge.obj', function (bridge ) {
  // For any meshes in the model, add our material.
  
   bridge.traverse( function ( node ) {
      if ( node.isMesh ) node.material = material3;
    } );
   
    // Add the model to the scene.
    bridge.rotation.y = -Math.PI / 2.75;
    bridge.position.y = 10;
    bridge.position.x = 150;
    bridge.scale.setScalar(15);
    bridge.castShadow = true;
    bridge.receiveShadow = false;
    scene.add(bridge );
} );
  }

// ----------------- MAP OBJECTS ---------------------------
  {
    const loader4 = new THREE.TextureLoader();
    const geometry = new THREE.BoxGeometry( 300, 100, 1 );
    const material = new THREE.MeshBasicMaterial( {map: loader4.load('/resources/images/buckle.jpg')} );
    const billBoard = new THREE.Mesh( geometry, material );
    billBoard.rotation.y = Math.PI/7
    billBoard.position.y = 150;
    billBoard.position.x = 275;
    billBoard.position.z = 300;
    billBoard.receiveShadow = true;
    scene.add( billBoard );
  }
  // HELICOPTER 1 ------------------------------------------------
  const geometry = new THREE.BoxGeometry( 50, 20, 20 );
  const geometry2 = new THREE.BoxGeometry( 50, 10, 10 );
  const geometry3 = new THREE.BoxGeometry( 120, 1, 3 );
  const geometry4 = new THREE.BoxGeometry( 10, 20, 10 );
  const geometry5 = new THREE.BoxGeometry( 3, 7, 3 );
  const loaderbody = new THREE.TextureLoader();
  const loaderbody2 = new THREE.TextureLoader();
  const loaderbody3 = new THREE.TextureLoader();
  const loaderbody4 = new THREE.TextureLoader();

  function makeLabelCanvas(baseWidth, size, name) {
    const borderSize = 2;
    const ctx = document.createElement('canvas').getContext('2d');
    const font =  `${size}px bold sans-serif`;
    ctx.font = font;
    // measure how long the name will be
    const textWidth = ctx.measureText(name).width;

    const doubleBorderSize = borderSize * 2;
    const width = baseWidth + doubleBorderSize;
    const height = size + doubleBorderSize;
    ctx.canvas.width = width;
    ctx.canvas.height = height;

    // need to set font again after resizing canvas
    ctx.font = font;
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'center';

    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, width, height);

    // scale to fit but don't stretch
    const scaleFactor = Math.min(1, baseWidth / textWidth);
    ctx.translate(width / 2, height / 2);
    ctx.scale(scaleFactor, 1);
    ctx.fillStyle = 'white';
    ctx.fillText(name, 0, 0);

    return ctx.canvas;
  }

  const materialbody = new THREE.MeshBasicMaterial( {map: loaderbody.load('/resources/images/metal.png')} );
    const body = new THREE.Mesh( geometry, materialbody );
    body.rotation.y = Math.PI/7;
    body.position.y = 150;
    body.position.x = 215;
    body.position.z = 150;
    body.castShadow = true;
    scene.add( body );

    var canvasL = makeLabelCanvas(100, 100, "Helicopter")
    const texture = new THREE.CanvasTexture(canvasL);
    texture.minFilter = THREE.LinearFilter;
    texture.wrapS = THREE.ClampToEdgeWrapping;
    texture.wrapT = THREE.ClampToEdgeWrapping;
    const labelMaterial = new THREE.SpriteMaterial({
    map: texture,
    transparent: true,
    });

    const label = new THREE.Sprite(labelMaterial);
    body.add(label);
    label.position.y = 20;
    label.scale.x = canvas.width  * 0.1;
    label.scale.y = canvas.height * 0.03;


    const materialstem = new THREE.MeshBasicMaterial( {color: 0xffffff} );
    const stem = new THREE.Mesh( geometry5, materialstem );
    stem.rotation.y = Math.PI/7;
    stem.position.y = body.position.y + 13;
    stem.position.x = body.position.x;
    stem.position.z = body.position.z;
    stem.castShadow = true;
    scene.add( stem );
    
    
    
    const materialtail = new THREE.MeshBasicMaterial( {map: loaderbody2.load('/resources/images/metal.jpg')} );
    const tail = new THREE.Mesh( geometry2, materialtail );
 
    tail.rotation.y = Math.PI/7
    tail.position.y = body.position.y + 3;
    tail.position.x = body.position.x + 30;
    tail.position.z = body.position.z - 15;
    tail.castShadow = true;
    scene.add( tail );

    const materialtail2 = new THREE.MeshBasicMaterial( {map: loaderbody3.load('/resources/images/wing.jpg')} );
    const tail2 = new THREE.Mesh( geometry4, materialtail2 );
    
    tail2.rotation.y = Math.PI/7
    
    tail2.position.y = body.position.y + 3;
    tail2.position.x = body.position.x + 50;
    tail2.position.z = body.position.z - 24;
    tail2.castShadow = true;
    scene.add( tail2 );
  
  function makeInstance(geometry, color, x) {
    const material3 = new THREE.MeshBasicMaterial( {color: 0x00000f} );
    const rotor = new THREE.Mesh( geometry3, material3 );
    rotor.position.y = body.position.y + 15;
    rotor.position.x = body.position.x ;
    rotor.position.z = body.position.z ;
    rotor.castShadow = true;
    
    scene.add( rotor );

    return rotor;
  }


  //// HELICOPTER 2 ------------------------------------------------
const twogeometry = new THREE.BoxGeometry( 50, 20, 20 );
  const twogeometry2 = new THREE.BoxGeometry( 50, 10, 10 );
  const twogeometry3 = new THREE.BoxGeometry( 120, 1, 3 );
  const twogeometry4 = new THREE.BoxGeometry( 10, 20, 10 );
  const twogeometry5 = new THREE.BoxGeometry( 3, 7, 3 );
  
  
    const twobody = new THREE.Mesh( twogeometry, materialbody );
    twobody.rotation.y = Math.PI/7;
    twobody.position.y = 200;
    twobody.position.x = 215;
    twobody.position.z = 0;
    twobody.castShadow = true;
    scene.add( twobody );


    const label2 = new THREE.Sprite(labelMaterial);
    twobody.add(label2);
    label2.position.y = 20;
    label2.scale.x = canvas.width  * 0.1;
    label2.scale.y = canvas.height * 0.03;

    const twostem = new THREE.Mesh( twogeometry5, materialstem );
    twostem.rotation.y = Math.PI/7;
    twostem.position.y = twobody.position.y + 13;
    twostem.position.x = twobody.position.x;
    twostem.position.z = twobody.position.z;
    twostem.castShadow = true;
    scene.add( twostem );
    
    
    
    
    const twotail = new THREE.Mesh( twogeometry2, materialtail );
 
    twotail.rotation.y = Math.PI/7
    twotail.position.y = twobody.position.y + 3;
    twotail.position.x = twobody.position.x + 30;
    twotail.position.z = twobody.position.z - 15;
    twotail.castShadow = true;
    scene.add( twotail );

   
    const twotail2 = new THREE.Mesh( twogeometry4, materialtail2 );
    
    twotail2.rotation.y = Math.PI/7
    
    twotail2.position.y = twobody.position.y + 3;
    twotail2.position.x = twobody.position.x + 50;
    twotail2.position.z = twobody.position.z - 24;
    twotail2.castShadow = true;
    scene.add( twotail2 );
  
  function makeInstance2(geometry, color, x) {
    const tworotor = new THREE.Mesh( twogeometry3, material3 );
    tworotor.position.y = twobody.position.y + 15;
    tworotor.position.x = twobody.position.x ;
    tworotor.position.z = twobody.position.z ;
    tworotor.castShadow = true;
    
    scene.add( tworotor );

    return tworotor;
  }
// HELICOPTER 3 -------------
  const threegeometry = new THREE.BoxGeometry( 50, 20, 20 );
  const threegeometry2 = new THREE.BoxGeometry( 50, 10, 10 );
  const threegeometry3 = new THREE.BoxGeometry( 120, 1, 3 );
  const threegeometry4 = new THREE.BoxGeometry( 10, 20, 10 );
  const threegeometry5 = new THREE.BoxGeometry( 3, 7, 3 );
  
  
    const threebody = new THREE.Mesh( threegeometry, materialbody );
    threebody.rotation.y = Math.PI/7;
    threebody.position.y = 140;
    threebody.position.x = 120;
    threebody.position.z = -150;
    threebody.castShadow = true;
    scene.add( threebody );

    const label3 = new THREE.Sprite(labelMaterial);
    threebody.add(label3);
    label3.position.y = 20;
    label3.scale.x = canvas.width  * 0.1;
    label3.scale.y = canvas.height * 0.03;
    
    const threestem = new THREE.Mesh( threegeometry5, materialstem );
    threestem.rotation.y = Math.PI/7;
    threestem.position.y = threebody.position.y + 13;
    threestem.position.x = threebody.position.x;
    threestem.position.z = threebody.position.z;
    threestem.castShadow = true;
    scene.add( threestem );
    
    
    
    
    const threetail = new THREE.Mesh( threegeometry2, materialtail );
 
    threetail.rotation.y = Math.PI/7
    threetail.position.y = threebody.position.y + 3;
    threetail.position.x = threebody.position.x + 30;
    threetail.position.z = threebody.position.z - 15;
    threetail.castShadow = true;
    scene.add( threetail );

   
    const threetail2 = new THREE.Mesh( threegeometry4, materialtail2 );
    
    threetail2.rotation.y = Math.PI/7
    
    threetail2.position.y = threebody.position.y + 3;
    threetail2.position.x = threebody.position.x + 50;
    threetail2.position.z = threebody.position.z - 24;
    threetail2.castShadow = true;
    scene.add( threetail2 );
  
  function makeInstance3(geometry, color, x) {
    const threerotor = new THREE.Mesh( threegeometry3, material3 );
    threerotor.position.y = threebody.position.y + 15;
    threerotor.position.x = threebody.position.x ;
    threerotor.position.z = threebody.position.z ;
    threerotor.castShadow = true;
    
    scene.add( threerotor );

    return threerotor;
  }










  const cubes = [
    makeInstance(geometry, 0x44aa88,  0),
    makeInstance2(geometry, 0x44aa88,  0),
    makeInstance3(geometry, 0x44aa88,  0),
  ];




  // ------------------ RENDER STUFF -------------------
  function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }

  function render(time) {
    time *= 0.001;  // convert time to seconds
    
    cubes.forEach((cube, ndx) => {
      const speed = 10 + ndx * .1;
      const rot = time * speed;
      //cube.rotation.x = rot;
      cube.rotation.y = rot;
    });

    if (resizeRendererToDisplaySize(renderer)) {
      const canvas = renderer.domElement;
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
    }
    //mapItems(time,0,geometry,geometry2,geometry3);
    renderer.render(scene, camera);

    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);
}

main();
</script>
</html>